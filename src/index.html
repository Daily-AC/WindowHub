<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WindowHub</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
      background-color: #1e1e2e;
      color: #cdd6f4;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* æ ‡ç­¾æ  */
    .tab-bar {
      flex: 0 0 50px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background-color: #181825;
      border-bottom: 1px solid #313244;
      overflow-x: visible; /* å…è®¸ä¸‹æ‹‰èœå•æº¢å‡º */
      white-space: nowrap;
      position: relative;
    }

    .logo {
      color: #89b4fa;
      font-size: 16px;
      font-weight: bold;
      margin-right: 12px;
    }
    
    .tabs-container {
        display: flex;
        gap: 8px;
        overflow-x: auto;
        flex: 1;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    .tabs-container::-webkit-scrollbar { display: none; }

    .tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      background-color: #313244;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      max-width: 200px;
      min-width: 100px;
      transition: background-color 0.2s;
      user-select: none;
    }

    .tab:hover {
      background-color: #45475a;
    }

    .tab.active {
      background-color: #89b4fa;
      color: #1e1e2e;
      font-weight: bold;
    }

    .tab-title {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 13px;
    }

    .tab-close {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 2px;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1;
      opacity: 0.7;
    }

    .tab-close:hover {
      background-color: rgba(255,255,255,0.2);
      opacity: 1;
    }

    /* å±…ä¸­æœç´¢å¼¹çª— */
    .search-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        z-index: 10000;
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 15vh;
    }
    
    .search-overlay.active {
        display: flex;
    }
    
    .search-panel {
        width: 500px;
        max-width: 90vw;
        background-color: #1e1e2e;
        border: 1px solid #45475a;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        overflow: hidden;
    }

    .search-input {
        width: 100%;
        padding: 16px 20px;
        background-color: transparent;
        border: none;
        border-bottom: 1px solid #313244;
        color: #cdd6f4;
        font-size: 16px;
        outline: none;
    }

    .search-input::placeholder {
        color: #6c7086;
    }

    .search-dropdown {
        max-height: 350px;
        overflow-y: auto;
    }

    .search-item {
        padding: 12px 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid #313244;
        color: #bac2de;
        transition: background-color 0.1s;
    }

    .search-item:hover,
    .search-item.selected {
        background-color: #313244;
        color: #fff;
    }
    
    .search-item:last-child {
        border-bottom: none;
    }
    
    .search-item-title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 14px;
    }
    
    .search-item-app {
        font-size: 11px;
        color: #6c7086;
    }
    
    .search-hint {
        padding: 8px 20px;
        font-size: 11px;
        color: #6c7086;
        background-color: #181825;
        text-align: center;
    }

    /* åµŒå…¥åŒºåŸŸ */
    .embed-area {
      flex: 1;
      position: relative;
      background-color: #11111b; 
      overflow: hidden;
      width: 100%;
    }

    /* æ¬¢è¿é¡µé¢ */
    .welcome {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      user-select: none;
    }

    .welcome h1 {
      font-size: 64px;
      margin-bottom: 16px;
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
    }

    .welcome p {
      color: #a6adc8;
      margin-bottom: 32px;
      font-size: 16px;
    }
    
    .drag-hint {
        border: 2px dashed #45475a;
        padding: 40px;
        border-radius: 16px;
        color: #6c7086;
    }
    
    /* æ‹–æ‹½åé¦ˆè¦†ç›–å±‚ */
    .drag-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(137, 180, 250, 0.2);
        border: 4px solid #89b4fa;
        z-index: 9999;
        display: none;
        pointer-events: none;
        align-items: center;
        justify-content: center;
    }
    .drag-overlay.active {
        display: flex;
    }
    .drag-overlay h2 {
        color: #89b4fa;
        background-color: #1e1e2e;
        padding: 20px 40px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="drag-overlay" id="drag-overlay">
      <h2>âœ¨ æ¾å¼€é¼ æ ‡åµŒå…¥çª—å£</h2>
  </div>

  <div class="tab-bar">
    <div class="logo">ğŸªŸ WindowHub</div>
    <div id="tabs" class="tabs-container"></div>
  </div>
  
  <!-- å±…ä¸­æœç´¢å¼¹çª— (Ctrl+K) -->
  <div class="search-overlay" id="search-overlay">
      <div class="search-panel">
          <input type="text" class="search-input" id="search-input" placeholder="ğŸ” æœç´¢å¹¶å¯åŠ¨åº”ç”¨..." autofocus />
          <div class="search-dropdown" id="search-dropdown"></div>
          <div class="search-hint">â†‘â†“ é€‰æ‹© Â· Enter ç¡®è®¤ Â· Esc å–æ¶ˆ</div>
      </div>
  </div>

  <div class="embed-area" id="embed-area">
    <div class="welcome">
      <h1>ğŸ‘‹</h1>
      <h2>WindowHub</h2>
      <p>å·¥ä½œæµèšåˆå·¥å…·</p>
      <div class="drag-hint">
          å°†çª—å£æ‹–æ‹½è‡³æ­¤
          <br>æˆ–ä½¿ç”¨å³ä¸Šè§’æœç´¢æ·»åŠ 
      </div>
    </div>
  </div>

  <script>
    window.onerror = function(msg, url, line, col, error) {
       alert("ğŸš¨ å…¨å±€é”™è¯¯:\n" + msg + "\nè¡Œå·: " + line + "\nåˆ—å·: " + col + "\né”™è¯¯: " + error);
       return false;
    };
    window.addEventListener('unhandledrejection', function(event) {
        alert("ğŸš¨ æœªæ•è·çš„ Promise å¼‚å¸¸:\n" + event.reason);
    });
  </script>

  <script type="module">
    const { invoke } = window.__TAURI__.core;
    const { listen } = window.__TAURI__.event;

    let embeddedWindows = []; // [{hwnd, title}]
    let activeHwnd = null;
    let isDragging = false;
    let dragEnterTime = 0;
    
    const embedArea = document.getElementById('embed-area');
    const tabsContainer = document.getElementById('tabs');
    const welcomeScreen = document.querySelector('.welcome');
    const dragOverlay = document.getElementById('drag-overlay');
    const searchInput = document.getElementById('search-input');
    const searchDropdown = document.getElementById('search-dropdown');
    // Ensure searchOverlay is available globally if possible, or duplicate logic
    const searchOverlay = document.getElementById('search-overlay');

    // -----------------------------------------------------------
    // åˆå§‹åŒ–
    // -----------------------------------------------------------
    async function init() {
        try {
            console.log("Initializing...");
            startDragDetection();
            setupResizeObserver();
            setupSearch();
            setupShortcuts();
            document.addEventListener('keydown', handleKeydown); 
            startDaemon(); // å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
            console.log("Init complete.");
        } catch(e) {
            alert("âŒ Init å¤±è´¥: " + e);
        }
    }
    
    // å»¶è¿Ÿæ‰§è¡Œ init ä»¥ç¡®ä¿ DOM å®Œå…¨å°±ç»ª (è™½ç„¶ module è„šæœ¬é€šå¸¸å·²å°±ç»ª)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // å…¨å±€å¿«æ·é”®ç›‘å¬ (æ¥è‡ª Rust äº‹ä»¶)
    async function setupShortcuts() {
        // Alt+1~9: åˆ‡æ¢åˆ°æŒ‡å®šæ ‡ç­¾
        await listen('switch-tab', (event) => {
            const index = event.payload - 1;
            if (index >= 0 && index < embeddedWindows.length) {
                switchTab(embeddedWindows[index].hwnd);
            }
        });
        
        // Ctrl+W: å…³é—­å½“å‰æ ‡ç­¾
        await listen('close-current-tab', () => {
            if (activeHwnd) {
                closeTab(activeHwnd);
            }
        });
        
        // Ctrl+Tab: ä¸‹ä¸€ä¸ªæ ‡ç­¾
        await listen('next-tab', () => {
            if (embeddedWindows.length <= 1) return;
            const currentIndex = embeddedWindows.findIndex(w => w.hwnd === activeHwnd);
            const nextIndex = (currentIndex + 1) % embeddedWindows.length;
            switchTab(embeddedWindows[nextIndex].hwnd);
        });
        
        // Ctrl+Shift+Tab: ä¸Šä¸€ä¸ªæ ‡ç­¾
        await listen('prev-tab', () => {
            if (embeddedWindows.length <= 1) return;
            const currentIndex = embeddedWindows.findIndex(w => w.hwnd === activeHwnd);
            const prevIndex = (currentIndex - 1 + embeddedWindows.length) % embeddedWindows.length;
            switchTab(embeddedWindows[prevIndex].hwnd);
        });
        
        // Ctrl+K: æ‰“å¼€æœç´¢å¼¹çª—
        await listen('open-search', () => {
            openSearchPanel();
        });
    }

    // -----------------------------------------------------------
    // æ ¸å¿ƒé€»è¾‘: æœç´¢åŠŸèƒ½ (å¼¹çª—æ¨¡å¼)
    // -----------------------------------------------------------
    let selectedSearchIndex = -1;

    
    // æ‰“å¼€æœç´¢é¢æ¿
    async function openSearchPanel() {
        // 1. éšè—æ‰€æœ‰åµŒå…¥çª—å£
        for (const w of embeddedWindows) {
            await invoke('hide_window', { targetHwnd: w.hwnd });
        }
        
        // 2. æ˜¾ç¤ºæœç´¢å¼¹çª—
        searchOverlay.classList.add('active');
        searchInput.value = '';
        searchInput.focus();
        selectedSearchIndex = -1;
        
        // 3. åŠ è½½åº”ç”¨åˆ—è¡¨
        await performSearch('');
    }
    
    // å…³é—­æœç´¢é¢æ¿
    async function closeSearchPanel() {
        searchOverlay.classList.remove('active');
        searchDropdown.innerHTML = '';
        
        // æ¢å¤æ‰€æœ‰åµŒå…¥çª—å£
        for (const w of embeddedWindows) {
            await invoke('show_window', { targetHwnd: w.hwnd });
        }
        
        // é‡æ–°æ¿€æ´»å½“å‰çª—å£
        if (activeHwnd) {
            await invoke('activate_window', { targetHwnd: activeHwnd });
        }
    }
    
    function setupSearch() {
        let debounceTimer;
        
        // è¾“å…¥äº‹ä»¶
        searchInput.addEventListener('input', (e) => {
            selectedSearchIndex = -1;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                performSearch(e.target.value);
            }, 200);
        });
        
        // é”®ç›˜å¯¼èˆª
        searchInput.addEventListener('keydown', (e) => {
            const items = searchDropdown.querySelectorAll('.search-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (items.length > 0) {
                    selectedSearchIndex = Math.min(selectedSearchIndex + 1, items.length - 1);
                    updateSearchSelection(items);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (items.length > 0) {
                    selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
                    updateSearchSelection(items);
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
                    items[selectedSearchIndex].click();
                } else if (items.length > 0) {
                    items[0].click();
                }
            } else if (e.key === 'Escape') {
                closeSearchPanel();
            }
        });
        
        // ç‚¹å‡»é®ç½©å±‚å…³é—­
        searchOverlay.addEventListener('click', (e) => {
            if (e.target === searchOverlay) {
                closeSearchPanel();
            }
        });
    }

    
    function updateSearchSelection(items) {
        items.forEach((item, i) => {
            if (i === selectedSearchIndex) {
                item.style.backgroundColor = '#45475a';
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.style.backgroundColor = '';
            }
        });
    }
    
    async function performSearch(query) {
        try {
            searchDropdown.innerHTML = '<div style="padding:10px;color:#6c7086;text-align:center">ğŸ” æ­£åœ¨æœç´¢åº”ç”¨...</div>';
            searchDropdown.classList.add('show');
            
            // åªæœç´¢å·²å®‰è£…åº”ç”¨
            const apps = await invoke('enumerate_installed_apps');
            
            // è¿‡æ»¤åº”ç”¨
            const filteredApps = query 
                ? apps.filter(a => a.name.toLowerCase().includes(query.toLowerCase()))
                : apps.slice(0, 15);
                
            if (filteredApps.length === 0) {
                searchDropdown.innerHTML = '<div style="padding:10px;color:#6c7086;text-align:center">æœªæ‰¾åˆ°åŒ¹é…çš„åº”ç”¨</div>';
                return;
            }
            
            // ä½¿ç”¨ data-* å±æ€§å­˜å‚¨è·¯å¾„ï¼Œé¿å…ç‰¹æ®Šå­—ç¬¦é—®é¢˜
            searchDropdown.innerHTML = filteredApps.slice(0, 15).map((a, i) => `
                <div class="search-item" data-path="${btoa(encodeURIComponent(a.path))}" data-name="${escapeHtml(a.name)}" onclick="window.handleAppClick(this)">
                    <div style="font-size:16px">ğŸ”¹</div>
                    <div style="flex:1;overflow:hidden;">
                        <div class="search-item-title">${escapeHtml(a.name)}</div>
                        <div class="search-item-app" style="font-size:10px;opacity:0.6">${escapeHtml(a.path.split('\\').pop())}</div>
                    </div>
                </div>
            `).join('');
            
        } catch(e) {
            console.error(e);
            searchDropdown.innerHTML = `<div style="padding:10px;color:red;">æœç´¢é”™è¯¯: ${e}</div>`;
        }
    }
    
    // å¤„ç†åº”ç”¨ç‚¹å‡»
    window.handleAppClick = function(el) {
        const encodedPath = el.dataset.path;
        const name = el.dataset.name;
        const path = decodeURIComponent(atob(encodedPath));
        launchAndEmbed(path, name);
    };
    
    // å¯åŠ¨åº”ç”¨å¹¶åµŒå…¥
    window.launchAndEmbed = async function(path, name) {
        closeSearchPanel();
        
        // æ˜¾ç¤ºå¯åŠ¨æç¤º
        const overlay = document.getElementById('drag-overlay');
        overlay.querySelector('h2').textContent = `ğŸš€ æ­£åœ¨å¯åŠ¨ ${name}...`;
        overlay.classList.add('active');
        
        try {
            const hwnd = await invoke('launch_app', { path });
            overlay.classList.remove('active');
            
            if (hwnd > 0) {
                await embedWindow(hwnd, name);
            }
        } catch (e) {
            overlay.classList.remove('active');
            alert('âŒ ' + e);
        }
    };

    // -----------------------------------------------------------
    // æ ¸å¿ƒé€»è¾‘: åµŒå…¥ä¸æ ‡ç­¾
    // -----------------------------------------------------------
    
    // åµŒå…¥çª—å£
    window.embedWindow = async function(hwnd, title) {
      // æ£€æŸ¥æ˜¯å¦å·²åµŒå…¥
      if (embeddedWindows.find(w => w.hwnd === hwnd)) {
          switchTab(hwnd);
          closeSearchPanel();
          return;
      }
      
      try {
        await invoke('embed_window', { targetHwnd: hwnd });
        
        embeddedWindows.push({ hwnd, title });
        activeHwnd = hwnd;
        
        renderTabs();
        updateUIState();
        
        closeSearchPanel();
        
        // å»¶æ—¶é‡ç½®å¤§å°ï¼Œç¡®ä¿æ¸²æŸ“æ­£ç¡®
        setTimeout(() => updateEmbeddedWindowSize(hwnd), 100);
        setTimeout(() => updateEmbeddedWindowSize(hwnd), 500); 
        
      } catch (e) {
        console.error('Embed failed:', e);
        if (e.includes("è‡ªèº«")) {
            alert('ğŸš« ä¸èƒ½åµŒå…¥ WindowHub è‡ªå·±ï¼');
        } else {
            alert('âŒ åµŒå…¥å¤±è´¥: ' + e);
        }
      }
    };

    // åˆ‡æ¢æ ‡ç­¾
    window.switchTab = async function(hwnd) {
      activeHwnd = hwnd;
      await invoke('activate_window', { targetHwnd: hwnd });
      updateEmbeddedWindowSize(hwnd); 
      renderTabs();
      closeSearchPanel(); // åˆ‡æ¢æ ‡ç­¾æ—¶å…³é—­æœç´¢
    };

    // å…³é—­æ ‡ç­¾
    window.closeTab = async function(hwnd) {
      try {
          await invoke('close_target_window', { targetHwnd: hwnd });
      } catch(e) {
          console.error("Close failed:", e);
      }
      removeWindowFromList(hwnd);
    };
    
    function removeWindowFromList(hwnd) {
      embeddedWindows = embeddedWindows.filter(w => w.hwnd !== hwnd);
      if (activeHwnd === hwnd) {
          if (embeddedWindows.length > 0) {
              const next = embeddedWindows[embeddedWindows.length - 1];
              switchTab(next.hwnd);
          } else {
              activeHwnd = null;
          }
      }
      renderTabs();
      updateUIState();
    }
    


    // æ›´æ–° UI çŠ¶æ€
    function updateUIState() {
        if (embeddedWindows.length === 0) {
            welcomeScreen.style.display = 'flex';
        } else {
            welcomeScreen.style.display = 'none';
        }
    }

    // æ¸²æŸ“æ ‡ç­¾
    function renderTabs() {
      tabsContainer.innerHTML = embeddedWindows.map(w => `
        <div class="tab ${w.hwnd === activeHwnd ? 'active' : ''}" 
             onclick="window.switchTab(${w.hwnd})"
             title="${w.title}">
          <span class="tab-title">${truncate(w.title)}</span>
          <button class="tab-close" onclick="event.stopPropagation(); window.closeTab(${w.hwnd})">âœ•</button>
        </div>
      `).join('');
    }
    
    function truncate(str) {
        return str.length > 15 ? str.slice(0, 12) + '...' : str;
    }
    
    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }

    // -----------------------------------------------------------
    // å®ˆæŠ¤è¿›ç¨‹ï¼šå­˜æ´»æ£€æŸ¥ + ä½ç½®é”å®š
    // -----------------------------------------------------------
    function startDaemon() {
        setInterval(async () => {
             for (const win of [...embeddedWindows]) {
                 const alive = await invoke('is_window_valid', { targetHwnd: win.hwnd });
                 if (!alive) {
                     removeWindowFromList(win.hwnd);
                 }
             }

             if (activeHwnd) {
                 updateEmbeddedWindowSize(activeHwnd);
             }
        }, 200);
    }
    startDaemon();

    // -----------------------------------------------------------
    // æ‹–æ‹½æ£€æµ‹ (Rust è¾…åŠ©)
    // -----------------------------------------------------------
    let mainHwnd = null;
    async function getMainHwnd() {
        if (!mainHwnd) { mainHwnd = await invoke('get_main_window_hwnd'); }
        return mainHwnd;
    }

    function startDragDetection() {
        setInterval(async () => {
            try {
                const isMouseDown = await invoke('is_mouse_left_down');
                if (!isDragging && !isMouseDown) return;

                const fgHwnd = await invoke('get_foreground_window');
                const myHwnd = await getMainHwnd();
                
                if (fgHwnd === myHwnd || isEmbedded(fgHwnd)) {
                    if (isDragging) {
                        isDragging = false;
                        dragOverlay.classList.remove('active');
                    }
                    return;
                }

                const isOver = await invoke('is_cursor_in_client_area', { topOffset: 50 });
                
                if (isMouseDown && isOver) {
                    if (!isDragging) {
                        isDragging = true;
                        dragEnterTime = Date.now();
                        dragOverlay.classList.add('active');
                    }
                } else {
                    if (isDragging) { 
                        isDragging = false;
                        dragOverlay.classList.remove('active');
                        
                        if (isOver && !isMouseDown && (Date.now() - dragEnterTime > 200)) {
                             const title = await invoke('get_window_title', { targetHwnd: fgHwnd });
                             if (title) {
                                 embedWindow(fgHwnd, title);
                             }
                        }
                    }
                }
            } catch (e) { }
        }, 100);
    }
    
    function isEmbedded(hwnd) {
        return embeddedWindows.some(w => w.hwnd === hwnd);
    }

    // -----------------------------------------------------------
    // è‡ªé€‚åº”å¤§å°
    // -----------------------------------------------------------
    function setupResizeObserver() {
        let resizeTimeout;
        const resizeObserver = new ResizeObserver(() => {
            if (!activeHwnd) return;
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(async () => {
                await updateEmbeddedWindowSize(activeHwnd);
                if (activeHwnd) {
                   await invoke('activate_window', { targetHwnd: activeHwnd });
                }
            }, 50);
        });
        resizeObserver.observe(embedArea);
    }
    
    async function updateEmbeddedWindowSize(hwnd) {
        const rect = embedArea.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        const physicalX = Math.round(rect.left * dpr);
        const physicalY = Math.round(rect.top * dpr);
        const physicalWidth = Math.round(rect.width * dpr);
        const physicalHeight = Math.round(rect.height * dpr);

        try {
            await invoke('update_window_rect', { 
                targetHwnd: hwnd, 
                x: physicalX,
                y: physicalY,
                width: physicalWidth, 
                height: physicalHeight
            });
        } catch(e) { console.error(e); }
    }

    // è¾…åŠ©åŠŸèƒ½
    function handleKeydown(e) {
        // ä¿ç•™åŸæœ‰çš„ Ctrl+1-9 æ”¯æŒï¼ˆä»…çª—å£èšç„¦æ—¶ï¼‰
        if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
            const index = parseInt(e.key) - 1;
            if (index < embeddedWindows.length) {
                switchTab(embeddedWindows[index].hwnd);
            }
        }
    }
  </script>
</body>
</html>
