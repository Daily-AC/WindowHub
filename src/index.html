<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WindowHub</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: "Segoe UI", "Microsoft YaHei", sans-serif;
      background-color: #1e1e2e;
      color: #cdd6f4;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* æ ‡ç­¾æ  */
    .tab-bar {
      flex: 0 0 50px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background-color: #181825;
      border-bottom: 1px solid #313244;
      overflow-x: visible; /* å…è®¸ä¸‹æ‹‰èœå•æº¢å‡º */
      white-space: nowrap;
      position: relative;
    }

    .logo {
      color: #89b4fa;
      font-size: 16px;
      font-weight: bold;
      margin-right: 12px;
    }
    
    .tabs-container {
        display: flex;
        gap: 8px;
        overflow-x: auto;
        flex: 1;
        scrollbar-width: none;
        -ms-overflow-style: none;
    }
    .tabs-container::-webkit-scrollbar { display: none; }

    .tab {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 16px;
      background-color: #313244;
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      max-width: 200px;
      min-width: 100px;
      transition: background-color 0.2s;
      user-select: none;
    }

    .tab:hover {
      background-color: #45475a;
    }

    .tab.active {
      background-color: #89b4fa;
      color: #1e1e2e;
      font-weight: bold;
    }

    .tab-title {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      font-size: 13px;
    }

    .tab-close {
      background: none;
      border: none;
      color: inherit;
      cursor: pointer;
      padding: 2px;
      border-radius: 4px;
      font-size: 14px;
      line-height: 1;
      opacity: 0.7;
    }

    .tab-close:hover {
      background-color: rgba(255,255,255,0.2);
      opacity: 1;
    }

    /* å±…ä¸­æœç´¢å¼¹çª— */
    .search-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.6);
        /* ç§»é™¤ backdrop-filter ä»¥ä¿®å¤ IME åæ ‡é—®é¢˜ */
        /* backdrop-filter: blur(4px); */ 
        z-index: 10000;
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 15vh;
    }
    
    /* é”™è¯¯å¼¹çª— (å±‚çº§æœ€é«˜) */
    .error-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: rgba(0,0,0,0.8);
        z-index: 20000;
        display: none;
        align-items: center;
        justify-content: center;
    }
    .error-overlay.active { display: flex; }
    .error-modal {
        background-color: #1e1e2e;
        padding: 24px;
        border-radius: 12px;
        border: 1px solid #eba0ac;
        box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        max-width: 400px;
        text-align: center;
    }
    .error-title { color: #eba0ac; font-size: 20px; margin-bottom: 12px; font-weight: bold; }
    .error-msg { color: #cdd6f4; font-size: 14px; margin-bottom: 24px; line-height: 1.5; white-space: pre-wrap; }
    .error-btn {
        background-color: #eba0ac; border: none; padding: 10px 24px; border-radius: 6px;
        color: #1e1e2e; font-weight: bold; cursor: pointer; transition: opacity 0.2s;
    }
    .error-btn:hover { opacity: 0.9; }
    
    .search-overlay.active {
        display: flex;
    }
    
    .search-panel {
        width: 500px;
        max-width: 90vw;
        background-color: #1e1e2e;
        border: 1px solid #45475a;
        border-radius: 12px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        overflow: hidden;
    }

    .search-input {
        width: 100%;
        padding: 16px;
        font-size: 20px;
        border: none;
        outline: none;
        color: #cdd6f4;
        background-color: #1e1e2e; /* å¿…é¡»æ˜¯å®å¿ƒèƒŒæ™¯ï¼Œå¸®åŠ© IME å®šä½ */
        border-bottom: 1px solid #313244;
    }

    .search-input::placeholder {
        color: #6c7086;
    }

    .search-dropdown {
        max-height: 350px;
        overflow-y: auto;
    }

    .search-item {
        padding: 12px 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid #313244;
        color: #bac2de;
        transition: background-color 0.1s;
    }

    .search-item:hover,
    .search-item.selected {
        background-color: #313244;
        color: #fff;
    }
    
    .search-item:last-child {
        border-bottom: none;
    }
    
    .search-item-title {
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        font-size: 14px;
    }
    
    .search-item-app {
        font-size: 11px;
        color: #6c7086;
    }
    
    .search-hint {
        padding: 8px 20px;
        font-size: 11px;
        color: #6c7086;
        background-color: #181825;
        text-align: center;
    }

    /* åµŒå…¥åŒºåŸŸ */
    .embed-area {
      flex: 1;
      position: relative;
      background-color: #11111b; 
      overflow: hidden;
      width: 100%;
    }

    /* æ¬¢è¿é¡µé¢ */
    .welcome {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      user-select: none;
    }

    .welcome h1 {
      font-size: 64px;
      margin-bottom: 16px;
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
        0% { transform: translateY(0px); }
        50% { transform: translateY(-10px); }
        100% { transform: translateY(0px); }
    }

    .welcome p {
      color: #a6adc8;
      margin-bottom: 32px;
      font-size: 16px;
    }
    
    .drag-hint {
        border: 2px dashed #45475a;
        padding: 40px;
        border-radius: 16px;
        color: #6c7086;
    }
    
    /* æ‹–æ‹½åé¦ˆè¦†ç›–å±‚ */
    .drag-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(137, 180, 250, 0.2);
        border: 4px solid #89b4fa;
        z-index: 9999;
        display: none;
        pointer-events: none;
        align-items: center;
        justify-content: center;
    }
    .drag-overlay.active {
        display: flex;
    }
    .drag-overlay h2 {
        color: #89b4fa;
        background-color: #1e1e2e;
        padding: 20px 40px;
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
    }
    
    /* å·¥ä½œåŒºå…¨å±è¦†ç›–å¼¹çª— (ç±»ä¼¼æœç´¢æ¡†) */
    .workspace-container {
        margin-left: auto;
    }
    .workspace-btn {
        background: linear-gradient(135deg, #89b4fa 0%, #cba6f7 100%);
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        color: #1e1e2e;
        font-weight: bold;
        cursor: pointer;
        font-size: 13px;
        transition: transform 0.2s, box-shadow 0.2s;
    }
    .workspace-btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(137,180,250,0.4);
    }
    .workspace-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        display: none;
        align-items: flex-start;
        justify-content: center;
        padding-top: 12vh;
    }
    .workspace-overlay.active { display: flex; }
    .workspace-panel {
        background-color: #1e1e2e;
        border: 1px solid #45475a;
        border-radius: 16px;
        width: 400px;
        max-width: 90vw;
        box-shadow: 0 20px 60px rgba(0,0,0,0.6);
        overflow: hidden;
        animation: slideDown 0.2s ease-out;
    }
    @keyframes slideDown {
        from { opacity: 0; transform: translateY(-20px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .workspace-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        background-color: #11111b;
        border-bottom: 1px solid #313244;
    }
    .workspace-header h3 {
        margin: 0;
        font-size: 16px;
        color: #cdd6f4;
    }
    .workspace-close {
        background: none;
        border: none;
        color: #6c7086;
        font-size: 20px;
        cursor: pointer;
        padding: 4px 8px;
        border-radius: 6px;
    }
    .workspace-close:hover { background-color: #313244; color: #f38ba8; }
    .workspace-list {
        max-height: 300px;
        overflow-y: auto;
    }
    .workspace-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 14px 20px;
        cursor: pointer;
        transition: background-color 0.15s;
        border-bottom: 1px solid #313244;
    }
    .workspace-item:hover { background-color: #313244; }
    .workspace-item:last-child { border-bottom: none; }
    .workspace-item-icon { font-size: 20px; }
    .workspace-item-info { flex: 1; }
    .workspace-item-name { font-weight: 500; margin-bottom: 2px; }
    .workspace-item-count { font-size: 11px; color: #6c7086; }
    .workspace-item-delete {
        opacity: 0; cursor: pointer; color: #f38ba8;
        background: none; border: none; font-size: 16px;
        padding: 4px 8px; border-radius: 4px;
    }
    .workspace-item:hover .workspace-item-delete { opacity: 1; }
    .workspace-item-delete:hover { background-color: rgba(243,139,168,0.2); }
    .workspace-footer {
        padding: 16px 20px;
        border-top: 1px solid #313244;
    }
    .workspace-save-btn {
        display: block;
        width: 100%;
        padding: 12px;
        border-radius: 10px;
        border: 2px dashed #45475a;
        background: transparent;
        color: #89b4fa;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s;
    }
    .workspace-save-btn:hover {
        background-color: rgba(137,180,250,0.15);
        border-color: #89b4fa;
    }
    .workspace-empty {
        padding: 40px 20px;
        text-align: center;
        color: #6c7086;
    }
    .workspace-empty-icon { font-size: 40px; margin-bottom: 12px; }
    .workspace-hint {
        padding: 12px 20px;
        text-align: center;
        font-size: 11px;
        color: #6c7086;
        background-color: #11111b;
    }
  </style>
</head>
<body>
  <div class="drag-overlay" id="drag-overlay">
      <h2>âœ¨ æ¾å¼€é¼ æ ‡åµŒå…¥çª—å£</h2>
  </div>

  <div class="tab-bar">
    <div class="logo">ğŸªŸ WindowHub</div>
    <div id="tabs" class="tabs-container"></div>
    
    <!-- å·¥ä½œåŒºæŒ‰é’® -->
    <div class="workspace-container">
        <button class="workspace-btn" onclick="openWorkspacePanel()">ğŸ“ å·¥ä½œåŒº</button>
    </div>
  </div>

  <!-- å·¥ä½œåŒºå…¨å±å¼¹çª— -->
  <div class="workspace-overlay" id="workspace-overlay">
      <div class="workspace-panel">
          <div class="workspace-header">
              <h3>ğŸ“ å·¥ä½œåŒºç®¡ç†</h3>
              <button class="workspace-close" onclick="closeWorkspacePanel()">âœ•</button>
          </div>
          <div class="workspace-list" id="workspace-list"></div>
          <div class="workspace-footer">
              <button class="workspace-save-btn" onclick="saveCurrentWorkspace()">â• ä¿å­˜å½“å‰ä¼šè¯ä¸ºå·¥ä½œåŒº</button>
          </div>
          <div class="workspace-hint">ç‚¹å‡»å·¥ä½œåŒºåç§°å¯ä¸€é”®æ¢å¤æ‰€æœ‰åº”ç”¨ Â· Esc å…³é—­</div>
      </div>
  </div>
  
  <!-- å±…ä¸­æœç´¢å¼¹çª— (Ctrl+K) -->
   <div class="search-overlay" id="search-overlay">
      <div class="search-panel">
          <input type="text" class="search-input" id="search-input" placeholder="ğŸ” æœç´¢åº”ç”¨æˆ–æ–‡ä»¶..." autofocus />
          <div class="search-dropdown" id="search-dropdown"></div>
          <div class="search-hint">â†‘â†“ é€‰æ‹© Â· Enter ç¡®è®¤ Â· Esc å–æ¶ˆ</div>
      </div>
  </div>

  <!-- é”™è¯¯å¼¹çª— -->
  <div class="error-overlay" id="error-overlay">
      <div class="error-modal">
          <div class="error-title">âš ï¸ æç¤º</div>
          <div class="error-msg" id="error-msg">å‘ç”Ÿäº†ä¸€äº›é”™è¯¯</div>
          <button class="error-btn" onclick="window.closeError()">çŸ¥é“äº†</button>
      </div>
  </div>

  <div class="embed-area" id="embed-area">
    <div class="welcome">
      <h1>ğŸ‘‹</h1>
      <h2>WindowHub</h2>
      <p>å·¥ä½œæµèšåˆå·¥å…·</p>
      <div class="drag-hint">
          å°†çª—å£æ‹–æ‹½è‡³æ­¤
          <br>æˆ–ä½¿ç”¨å³ä¸Šè§’æœç´¢æ·»åŠ 
      </div>
    </div>
  </div>

  <script>
    /* window.onerror å·²æ¥ç®¡ */
    /* window.addEventListener('unhandledrejection'...) å·²æ¥ç®¡ */
  </script>

  <script type="module">
    const { invoke } = window.__TAURI__.core;
    const { listen } = window.__TAURI__.event;

    let embeddedWindows = []; // [{hwnd, title}]
    let activeHwnd = null;
    let isDragging = false;
    let dragEnterTime = 0;
    
    const embedArea = document.getElementById('embed-area');
    const tabsContainer = document.getElementById('tabs');
    const welcomeScreen = document.querySelector('.welcome');
    const dragOverlay = document.getElementById('drag-overlay');
    const searchInput = document.getElementById('search-input');
    const searchDropdown = document.getElementById('search-dropdown');
    // Ensure searchOverlay is available globally if possible, or duplicate logic
    const searchOverlay = document.getElementById('search-overlay');
    const errorOverlay = document.getElementById('error-overlay');
    const errorMsg = document.getElementById('error-msg');

    // -----------------------------------------------------------
    // é”™è¯¯å¤„ç† (è‡ªå®šä¹‰æ¨¡æ€æ¡†)
    // -----------------------------------------------------------
    window.showError = async function(msg) {
        console.error("SHOW Error:", msg);
        errorMsg.textContent = msg;
        
        // éšè—æ‰€æœ‰çª—å£ï¼Œé˜²æ­¢é®æŒ¡
        for (const w of embeddedWindows) {
            await invoke('hide_window', { targetHwnd: w.hwnd });
        }
        
        errorOverlay.classList.add('active');
    };

    window.closeError = async function() {
        errorOverlay.classList.remove('active');
        // æ¢å¤çª—å£
        for (const w of embeddedWindows) {
            await invoke('show_window', { targetHwnd: w.hwnd });
        }
        // é‡æ–°èšç„¦å½“å‰çª—å£
        if (activeHwnd) {
             await invoke('activate_window', { targetHwnd: activeHwnd });
        }
    };
    
    // è¦†ç›–å…¨å±€ onerror
    window.onerror = function(msg) {
       window.showError("å…¨å±€é”™è¯¯: " + msg);
       return true; // é˜»æ­¢é»˜è®¤ alert
    };
    window.addEventListener('unhandledrejection', function(event) {
        window.showError("æœªè· Promise å¼‚å¸¸: " + (event.reason ? event.reason.message : event.reason));
    });

    // -----------------------------------------------------------
    // åˆå§‹åŒ–
    // -----------------------------------------------------------
    async function init() {
        try {
            console.log("Initializing...");
            startDragDetection();
            setupResizeObserver();
            setupSearch();
            setupShortcuts();
            document.addEventListener('keydown', handleKeydown); 
            startDaemon(); // å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹
            console.log("Init complete.");
        } catch(e) {
            alert("âŒ Init å¤±è´¥: " + e);
        }
    }
    
    // å»¶è¿Ÿæ‰§è¡Œ init ä»¥ç¡®ä¿ DOM å®Œå…¨å°±ç»ª (è™½ç„¶ module è„šæœ¬é€šå¸¸å·²å°±ç»ª)
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // å…³é”®ä¼˜åŒ–ï¼šå½“ WindowHub çª—å£æœ¬èº«è·å¾—ç„¦ç‚¹æ—¶ï¼ˆä¾‹å¦‚æ‹–æ‹½ç»“æŸã€ç‚¹å‡»æ ‡é¢˜æ ï¼‰ï¼Œè‡ªåŠ¨æŠŠç„¦ç‚¹"å›ä¼ "
    window.addEventListener('focus', async () => {
         const searchActive = document.getElementById('search-overlay').classList.contains('active');
         const workspaceActive = document.getElementById('workspace-overlay').classList.contains('active');
         
         // åœºæ™¯0: å·¥ä½œåŒºä¸‹æ‹‰èœå•æ‰“å¼€æ—¶ï¼Œä¸è¦æ¢å¤åµŒå…¥çª—å£
         if (workspaceActive) {
              console.log("Workspace dropdown active, skipping focus restore");
              return;
         }
         
         // åœºæ™¯1: æœç´¢æ¡†æ‰“å¼€æ—¶ï¼Œç§»åŠ¨çª—å£åé‡æ–°èšç„¦æœç´¢æ¡† (ä¿®å¤ IME ä¸¢å¤±)
         if (searchActive) {
             console.log("Restoring focus to Search Input...");
             document.getElementById('search-input').focus();
             return;
         }
         
         // åœºæ™¯2: æœç´¢æ¡†æœªæ‰“å¼€ï¼Œä¸”æœ‰åµŒå…¥çª—å£ï¼Œèšç„¦åµŒå…¥çª—å£
         if (document.getElementById('error-overlay').classList.contains('active')) return;

         if (activeHwnd) {
             console.log("Restoring focus to embedded app...");
             await invoke('activate_window', { targetHwnd: activeHwnd });
         }
    });

    // ç›‘å¬é‡æ–°è°ƒæ•´å¤§å°ï¼Œä¹Ÿå¼ºåˆ¶èšç„¦æœç´¢æ¡† (ä¿®å¤ resize å IME ä¸¢å¤±)
    window.addEventListener('resize', () => {
         if (document.getElementById('search-overlay').classList.contains('active')) {
             document.getElementById('search-input').focus();
         }
         // åŒæ—¶ä¹Ÿè®©åµŒå…¥çª—å£é€‚åº”æ–°å¤§å°
         if (activeHwnd) updateEmbeddedWindowSize(activeHwnd);
    });

    // å…¨å±€å¿«æ·é”®ç›‘å¬ (æ¥è‡ª Rust äº‹ä»¶)
    async function setupShortcuts() {
        // Alt+1~9: åˆ‡æ¢åˆ°æŒ‡å®šæ ‡ç­¾
        await listen('switch-tab', (event) => {
            const index = event.payload - 1;
            if (index >= 0 && index < embeddedWindows.length) {
                switchTab(embeddedWindows[index].hwnd);
            }
        });
        
        // Ctrl+W: å…³é—­å½“å‰æ ‡ç­¾
        await listen('close-current-tab', () => {
            if (activeHwnd) {
                closeTab(activeHwnd);
            }
        });
        
        // Ctrl+Tab: ä¸‹ä¸€ä¸ªæ ‡ç­¾
        await listen('next-tab', () => {
            if (embeddedWindows.length <= 1) return;
            const currentIndex = embeddedWindows.findIndex(w => w.hwnd === activeHwnd);
            const nextIndex = (currentIndex + 1) % embeddedWindows.length;
            switchTab(embeddedWindows[nextIndex].hwnd);
        });
        
        // Ctrl+Shift+Tab: ä¸Šä¸€ä¸ªæ ‡ç­¾
        await listen('prev-tab', () => {
            if (embeddedWindows.length <= 1) return;
            const currentIndex = embeddedWindows.findIndex(w => w.hwnd === activeHwnd);
            const prevIndex = (currentIndex - 1 + embeddedWindows.length) % embeddedWindows.length;
            switchTab(embeddedWindows[prevIndex].hwnd);
        });
        
        // Ctrl+K: æ‰“å¼€æœç´¢å¼¹çª—
        await listen('open-search', () => {
            openSearchPanel();
        });

        // Ctrl+D: å¼¹å‡ºå½“å‰çª—å£
        await listen('detach-current-tab', () => {
            if (activeHwnd) {
                detachTab(activeHwnd);
            }
        });
        
        // çª—å£å…³é—­æ—¶é‡Šæ”¾æ‰€æœ‰åµŒå…¥çª—å£ï¼ˆé˜²æ­¢å†»ç»“ï¼‰
        await listen('release-all-windows', async () => {
            console.log('é‡Šæ”¾æ‰€æœ‰åµŒå…¥çª—å£...');
            for (const w of [...embeddedWindows]) {
                try {
                    await invoke('release_window', { targetHwnd: w.hwnd });
                } catch(e) {
                    console.warn('é‡Šæ”¾çª—å£å¤±è´¥:', w.hwnd, e);
                }
            }
            embeddedWindows.length = 0;
            activeHwnd = null;
        });
    }

    // -----------------------------------------------------------
    // æ ¸å¿ƒé€»è¾‘: æœç´¢åŠŸèƒ½ (å¼¹çª—æ¨¡å¼)
    // -----------------------------------------------------------
    let selectedSearchIndex = -1;

    
    // æ‰“å¼€æœç´¢é¢æ¿
    async function openSearchPanel() {
        if (searchOverlay.classList.contains('active')) return;
        
        // 1. éšè—æ‰€æœ‰åµŒå…¥çª—å£ (é˜²æ­¢ Z-Index é®æŒ¡)
        for (const w of embeddedWindows) {
            await invoke('hide_window', { targetHwnd: w.hwnd });
        }
        
        // 2. æ˜¾ç¤ºæœç´¢å¼¹çª—
        searchOverlay.classList.add('active');
        searchInput.value = '';
        searchDropdown.innerHTML = '';
        searchDropdown.classList.remove('show');
        
        // å…³é”®ä¿®å¤ï¼šå»¶è¿Ÿèšç„¦ï¼Œç­‰å¾…å¸ƒå±€ç¨³å®šï¼Œç¡®ä¿ IME åæ ‡æ­£ç¡®
        setTimeout(() => {
            searchInput.focus();
        }, 50);
        
        // 3. åŠ è½½é»˜è®¤åˆ—è¡¨
        selectedSearchIndex = -1;
        await performSearch('');
    }
    
    // å…³é—­æœç´¢é¢æ¿
    async function closeSearchPanel() {
        searchOverlay.classList.remove('active');
        searchDropdown.innerHTML = '';
        
        // æ¢å¤æ‰€æœ‰åµŒå…¥çª—å£
        for (const w of embeddedWindows) {
            await invoke('show_window', { targetHwnd: w.hwnd });
        }
        
        // é‡æ–°æ¿€æ´»å½“å‰çª—å£
        if (activeHwnd) {
            await invoke('activate_window', { targetHwnd: activeHwnd });
        }
    }
    
    function setupSearch() {
        let debounceTimer;
        
        // è¾“å…¥äº‹ä»¶
        searchInput.addEventListener('input', (e) => {
            selectedSearchIndex = -1;
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                performSearch(e.target.value);
            }, 200);
        });
        
        // é”®ç›˜å¯¼èˆª
        searchInput.addEventListener('keydown', (e) => {
            const items = searchDropdown.querySelectorAll('.search-item');
            
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (items.length > 0) {
                    selectedSearchIndex = Math.min(selectedSearchIndex + 1, items.length - 1);
                    updateSearchSelection(items);
                }
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (items.length > 0) {
                    selectedSearchIndex = Math.max(selectedSearchIndex - 1, 0);
                    updateSearchSelection(items);
                }
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
                    items[selectedSearchIndex].click();
                } else if (items.length > 0) {
                    items[0].click();
                }
            } else if (e.key === 'Escape') {
                closeSearchPanel();
            }
        });
        
        // ç‚¹å‡»é®ç½©å±‚å…³é—­
        searchOverlay.addEventListener('click', (e) => {
            if (e.target === searchOverlay) {
                closeSearchPanel();
            }
        });
    }

    
    function updateSearchSelection(items) {
        items.forEach((item, i) => {
            if (i === selectedSearchIndex) {
                item.style.backgroundColor = '#45475a';
                item.scrollIntoView({ block: 'nearest' });
            } else {
                item.style.backgroundColor = '';
            }
        });
    }
    
    async function performSearch(query) {
        try {
            searchDropdown.innerHTML = '<div style="padding:10px;color:#6c7086;text-align:center">ğŸ” æ­£åœ¨æœç´¢...</div>';
            searchDropdown.classList.add('show');
            
            // å¹¶è¡Œæœç´¢åº”ç”¨å’Œæ–‡ä»¶
            const pApps = invoke('enumerate_installed_apps');
            const pFiles = query ? invoke('search_files', { query }) : Promise.resolve([]);
            
            const [apps, files] = await Promise.all([pApps, pFiles]);
            
            let html = '';
            
            // è¿‡æ»¤åº”ç”¨
            const filteredApps = query 
                ? apps.filter(a => a.name.toLowerCase().includes(query.toLowerCase()))
                : apps.slice(0, 15);
            
            if (filteredApps.length > 0) {
                html += `<div style="padding:8px 20px;font-size:12px;color:#585b70;font-weight:bold;background:#11111b">åº”ç”¨</div>`;
                html += filteredApps.slice(0, 10).map(a => renderItem(a.name, a.path, 'åº”ç”¨')).join('');
            }
            
            if (files.length > 0) {
                html += `<div style="padding:8px 20px;font-size:12px;color:#585b70;font-weight:bold;background:#11111b;border-top:1px solid #313244">æ–‡ä»¶</div>`;
                html += files.slice(0, 10).map(f => renderItem(f.name, f.path, f.is_dir ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶')).join('');
            }
            
            if (html === '') {
                html = '<div style="padding:10px;color:#6c7086;text-align:center">æœªæ‰¾åˆ°åŒ¹é…é¡¹</div>';
            }
            
            searchDropdown.innerHTML = html;
            
        } catch(e) {
            console.error(e);
            searchDropdown.innerHTML = `<div style="padding:10px;color:red;">æœç´¢é”™è¯¯: ${e}</div>`;
        }
    }

    function renderItem(name, path, type) {
        return `
            <div class="search-item" data-path="${btoa(encodeURIComponent(path))}" data-name="${escapeHtml(name)}" onclick="window.handleAppClick(this)">
                <div style="font-size:16px">${type === 'åº”ç”¨' ? 'ğŸš€' : (type === 'æ–‡ä»¶å¤¹' ? 'ğŸ“‚' : 'ğŸ“„')}</div>
                <div style="flex:1;overflow:hidden;">
                    <div class="search-item-title">${escapeHtml(name)}</div>
                    <div class="search-item-app">${type} Â· ${escapeHtml(path)}</div>
                </div>
            </div>
        `;
    }
    
    // å¤„ç†åº”ç”¨ç‚¹å‡»
    window.handleAppClick = function(el) {
        const encodedPath = el.dataset.path;
        const name = el.dataset.name;
        const path = decodeURIComponent(atob(encodedPath));
        launchAndEmbed(path, name);
    };
    
    // å¯åŠ¨åº”ç”¨å¹¶åµŒå…¥
    window.launchAndEmbed = async function(path, name) {
        closeSearchPanel();
        
        // æ˜¾ç¤ºå¯åŠ¨æç¤º
        const overlay = document.getElementById('drag-overlay');
        overlay.querySelector('h2').textContent = `ğŸš€ æ­£åœ¨å¯åŠ¨ ${name}...`;
        overlay.classList.add('active');
        
        try {
            const hwnd = await invoke('launch_app', { path });
            overlay.classList.remove('active');
            
            if (hwnd > 0) {
                await embedWindow(hwnd, name);
            }
        } catch (e) {
            overlay.classList.remove('active');
            window.showError('å¯åŠ¨å¤±è´¥: ' + e);
        }
    };

    // -----------------------------------------------------------
    // æ ¸å¿ƒé€»è¾‘: åµŒå…¥ä¸æ ‡ç­¾
    // -----------------------------------------------------------
    
    // åµŒå…¥çª—å£
    window.embedWindow = async function(hwnd, title) {
      // æ£€æŸ¥æ˜¯å¦å·²åµŒå…¥
      if (embeddedWindows.find(w => w.hwnd === hwnd)) {
          switchTab(hwnd);
          closeSearchPanel();
          return;
      }
      
      try {
        await invoke('embed_window', { targetHwnd: hwnd });
        
        embeddedWindows.push({ hwnd, title });
        activeHwnd = hwnd;
        
        renderTabs();
        updateUIState();
        
        closeSearchPanel();
        
        // å»¶æ—¶é‡ç½®å¤§å°ï¼Œç¡®ä¿æ¸²æŸ“æ­£ç¡®
        setTimeout(() => updateEmbeddedWindowSize(hwnd), 100);
        setTimeout(() => {
             updateEmbeddedWindowSize(hwnd);
             invoke('activate_window', { targetHwnd: hwnd });
             // åŒé‡ä¿é™©ï¼šå†æ¬¡å¼ºåˆ¶é‡ç»˜
             invoke('force_repaint', { targetHwnd: hwnd });
        }, 500); 
        
      } catch (e) {
        console.error('Embed failed:', e);
        if (e.includes("è‡ªèº«")) {
            alert('ğŸš« ä¸èƒ½åµŒå…¥ WindowHub è‡ªå·±ï¼');
        } else {
            alert('âŒ åµŒå…¥å¤±è´¥: ' + e);
        }
      }
    };

    // åˆ‡æ¢æ ‡ç­¾
    window.switchTab = async function(hwnd) {
      activeHwnd = hwnd;
      await invoke('activate_window', { targetHwnd: hwnd });
      // å†æ¬¡å°è¯•æ¿€æ´»ï¼Œç¡®ä¿è¾“å…¥ç„¦ç‚¹
      setTimeout(() => invoke('activate_window', { targetHwnd: hwnd }), 50);
      
      updateEmbeddedWindowSize(hwnd); 
      renderTabs();
      closeSearchPanel(); // åˆ‡æ¢æ ‡ç­¾æ—¶å…³é—­æœç´¢
    };

    // å…³é—­æ ‡ç­¾
    window.closeTab = async function(hwnd) {
      // ç”¨æˆ·åé¦ˆï¼šä¸éœ€è¦ç¡®è®¤å¼¹çª—ï¼Œç›´æ¥å…³é—­
      try {
          await invoke('close_target_window', { targetHwnd: hwnd });
      } catch(e) {
          console.error("Close failed:", e);
      }
      removeWindowFromList(hwnd);
    };

    // å¼¹å‡ºæ ‡ç­¾ (Detach)
    window.detachTab = async function(hwnd) {
      try {
          await invoke('release_window', { targetHwnd: hwnd });
      } catch(e) {
          console.error("Release failed:", e);
      }
      removeWindowFromList(hwnd);
    };
    
    function removeWindowFromList(hwnd) {
      embeddedWindows = embeddedWindows.filter(w => w.hwnd !== hwnd);
      if (activeHwnd === hwnd) {
          if (embeddedWindows.length > 0) {
              const next = embeddedWindows[embeddedWindows.length - 1];
              switchTab(next.hwnd);
          } else {
              activeHwnd = null;
          }
      }
      renderTabs();
      updateUIState();
    }
    


    // æ›´æ–° UI çŠ¶æ€
    function updateUIState() {
        if (embeddedWindows.length === 0) {
            welcomeScreen.style.display = 'flex';
        } else {
            welcomeScreen.style.display = 'none';
        }
    }

    // æ¸²æŸ“æ ‡ç­¾
    function renderTabs() {
      tabsContainer.innerHTML = embeddedWindows.map(w => `
        <div class="tab ${w.hwnd === activeHwnd ? 'active' : ''}" 
             onclick="window.switchTab(${w.hwnd})"
             title="${w.title}">
          <span class="tab-title">${truncate(w.title)}</span>
          <button class="tab-close" onclick="event.stopPropagation(); window.detachTab(${w.hwnd})" title="å¼¹å‡ºçª—å£ (Ctrl+D)" style="margin-right:4px">â</button>
          <button class="tab-close" onclick="event.stopPropagation(); window.closeTab(${w.hwnd})" title="å…³é—­çª—å£">âœ•</button>
        </div>
      `).join('');
    }
    
    function truncate(str) {
        return str.length > 15 ? str.slice(0, 12) + '...' : str;
    }
    
    function escapeHtml(str) {
        if (!str) return '';
        return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
    }

    // -----------------------------------------------------------
    // å®ˆæŠ¤è¿›ç¨‹ï¼šå­˜æ´»æ£€æŸ¥ + ä½ç½®é”å®š
    // -----------------------------------------------------------
    function startDaemon() {
        setInterval(async () => {
             for (const win of [...embeddedWindows]) {
                 const alive = await invoke('is_window_valid', { targetHwnd: win.hwnd });
                 if (!alive) {
                     removeWindowFromList(win.hwnd);
                 }
             }

             if (activeHwnd) {
                 updateEmbeddedWindowSize(activeHwnd);
             }
        }, 200);
    }
    startDaemon();

    // -----------------------------------------------------------
    // æ‹–æ‹½æ£€æµ‹ (Rust è¾…åŠ©)
    // -----------------------------------------------------------
    let mainHwnd = null;
    async function getMainHwnd() {
        if (!mainHwnd) { mainHwnd = await invoke('get_main_window_hwnd'); }
        return mainHwnd;
    }

    function startDragDetection() {
        setInterval(async () => {
            try {
                const isMouseDown = await invoke('is_mouse_left_down');
                if (!isDragging && !isMouseDown) return;

                const fgHwnd = await invoke('get_foreground_window');
                const myHwnd = await getMainHwnd();
                
                if (fgHwnd === myHwnd || isEmbedded(fgHwnd)) {
                    if (isDragging) {
                        isDragging = false;
                        dragOverlay.classList.remove('active');
                    }
                    return;
                }

                const isOver = await invoke('is_cursor_in_client_area', { topOffset: 50 });
                
                if (isMouseDown && isOver) {
                    if (!isDragging) {
                        isDragging = true;
                        dragEnterTime = Date.now();
                        dragOverlay.classList.add('active');
                    }
                } else {
                    if (isDragging) { 
                        isDragging = false;
                        dragOverlay.classList.remove('active');
                        
                        if (isOver && !isMouseDown && (Date.now() - dragEnterTime > 200)) {
                             const title = await invoke('get_window_title', { targetHwnd: fgHwnd });
                             if (title) {
                                 embedWindow(fgHwnd, title);
                             }
                        }
                    }
                }
            } catch (e) { }
        }, 100);
    }
    
    function isEmbedded(hwnd) {
        return embeddedWindows.some(w => w.hwnd === hwnd);
    }

    // -----------------------------------------------------------
    // è‡ªé€‚åº”å¤§å°
    // -----------------------------------------------------------
    function setupResizeObserver() {
        let resizeTimeout;
        const resizeObserver = new ResizeObserver(() => {
            if (!activeHwnd) return;
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(async () => {
                await updateEmbeddedWindowSize(activeHwnd);
                if (activeHwnd) {
                   await invoke('activate_window', { targetHwnd: activeHwnd });
                }
            }, 50);
        });
        resizeObserver.observe(embedArea);
    }
    
    async function updateEmbeddedWindowSize(hwnd) {
        const rect = embedArea.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        
        const physicalX = Math.round(rect.left * dpr);
        const physicalY = Math.round(rect.top * dpr);
        const physicalWidth = Math.round(rect.width * dpr);
        const physicalHeight = Math.round(rect.height * dpr);

        try {
            await invoke('update_window_rect', { 
                targetHwnd: hwnd, 
                x: physicalX,
                y: physicalY,
                width: physicalWidth, 
                height: physicalHeight
            });
        } catch(e) { console.error(e); }
    }

    // è¾…åŠ©åŠŸèƒ½
    function handleKeydown(e) {
        // ä¿ç•™åŸæœ‰çš„ Ctrl+1-9 æ”¯æŒï¼ˆä»…çª—å£èšç„¦æ—¶ï¼‰
        if (e.ctrlKey && e.key >= '1' && e.key <= '9') {
            const index = parseInt(e.key) - 1;
            if (index < embeddedWindows.length) {
                switchTab(embeddedWindows[index].hwnd);
            }
        }
    }

    // -----------------------------------------------------------
    // å·¥ä½œåŒº (Workspace) åŠŸèƒ½ - å…¨å±å¼¹çª—æ¨¡å¼
    // -----------------------------------------------------------
    const workspaceOverlay = document.getElementById('workspace-overlay');
    const workspaceList = document.getElementById('workspace-list');

    // æ‰“å¼€å·¥ä½œåŒºé¢æ¿
    window.openWorkspacePanel = async function() {
        if (workspaceOverlay.classList.contains('active')) return;
        
        console.log('[Workspace] Opening panel');
        
        // å…ˆæ ‡è®°ä¸ºæ´»è·ƒçŠ¶æ€ï¼Œé˜»æ­¢ focus ç›‘å¬å™¨æ¢å¤çª—å£
        workspaceOverlay.classList.add('active');
        loadWorkspaces();
        
        // ç„¶åéšè—åµŒå…¥çª—å£
        for (const w of embeddedWindows) {
            await invoke('hide_window', { targetHwnd: w.hwnd });
        }
    };

    // å…³é—­å·¥ä½œåŒºé¢æ¿
    window.closeWorkspacePanel = async function() {
        workspaceOverlay.classList.remove('active');
        
        // æ¢å¤åµŒå…¥çª—å£
        for (const w of embeddedWindows) {
            await invoke('show_window', { targetHwnd: w.hwnd });
        }
        if (activeHwnd) {
            await invoke('activate_window', { targetHwnd: activeHwnd });
        }
    };

    // ç‚¹å‡»é®ç½©å±‚å…³é—­
    workspaceOverlay.addEventListener('click', (e) => {
        if (e.target === workspaceOverlay) {
            closeWorkspacePanel();
        }
    });

    // Esc å…³é—­é¢æ¿
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && workspaceOverlay.classList.contains('active')) {
            closeWorkspacePanel();
        }
    });

    // åŠ è½½å·¥ä½œåŒºåˆ—è¡¨
    async function loadWorkspaces() {
        try {
            const workspaces = await invoke('get_workspaces');
            if (workspaces.length === 0) {
                workspaceList.innerHTML = `
                    <div class="workspace-empty">
                        <div class="workspace-empty-icon">ğŸ“‚</div>
                        æš‚æ— ä¿å­˜çš„å·¥ä½œåŒº<br>
                        <span style="font-size: 12px;">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ä¿å­˜å½“å‰ä¼šè¯</span>
                    </div>`;
                return;
            }
            workspaceList.innerHTML = workspaces.map(ws => `
                <div class="workspace-item" onclick="restoreWorkspace('${escapeHtml(ws.name)}')">
                    <span class="workspace-item-icon">ğŸ—‚ï¸</span>
                    <div class="workspace-item-info">
                        <div class="workspace-item-name">${escapeHtml(ws.name)}</div>
                        <div class="workspace-item-count">${ws.apps.length} ä¸ªåº”ç”¨</div>
                    </div>
                    <button class="workspace-item-delete" onclick="event.stopPropagation(); deleteWorkspace('${escapeHtml(ws.name)}')" title="åˆ é™¤">ğŸ—‘ï¸</button>
                </div>
            `).join('');
        } catch(e) {
            console.error('åŠ è½½å·¥ä½œåŒºå¤±è´¥:', e);
            workspaceList.innerHTML = '<div class="workspace-empty">åŠ è½½å¤±è´¥</div>';
        }
    }

    // ä¿å­˜å½“å‰ä¼šè¯ä¸ºå·¥ä½œåŒº
    window.saveCurrentWorkspace = async function() {
        if (embeddedWindows.length === 0) {
            window.showError('å½“å‰æ²¡æœ‰åµŒå…¥çš„çª—å£ï¼Œæ— æ³•ä¿å­˜å·¥ä½œåŒº');
            return;
        }
        
        const name = prompt('è¯·ä¸ºå·¥ä½œåŒºå‘½å:', `å·¥ä½œåŒº ${new Date().toLocaleDateString()}`);
        if (!name || !name.trim()) return;
        
        try {
            const hwnds = embeddedWindows.map(w => w.hwnd);
            await invoke('save_workspace', { name: name.trim(), hwnds });
            closeWorkspacePanel();
            console.log('å·¥ä½œåŒºä¿å­˜æˆåŠŸ:', name);
        } catch(e) {
            window.showError('ä¿å­˜å¤±è´¥: ' + e);
        }
    };

    // åˆ é™¤å·¥ä½œåŒº
    window.deleteWorkspace = async function(name) {
        if (!confirm(`ç¡®å®šè¦åˆ é™¤å·¥ä½œåŒº "${name}" å—ï¼Ÿ`)) return;
        
        try {
            await invoke('delete_workspace', { name });
            loadWorkspaces();
        } catch(e) {
            window.showError('åˆ é™¤å¤±è´¥: ' + e);
        }
    };

    // æ¢å¤å·¥ä½œåŒº
    window.restoreWorkspace = async function(name) {
        closeWorkspacePanel();
        
        try {
            const apps = await invoke('restore_workspace', { name });
            console.log('æ¢å¤å·¥ä½œåŒº:', name, apps);
            
            for (const path of apps) {
                try {
                    console.log('å¯åŠ¨åº”ç”¨:', path);
                    const hwnd = await invoke('launch_app', { path });
                    console.log('launch_app è¿”å›:', hwnd);
                    
                    if (hwnd > 0) {
                        const title = await invoke('get_window_title', { targetHwnd: hwnd });
                        console.log('åµŒå…¥çª—å£:', hwnd, title);
                        await embedWindow(hwnd, title || path.split('\\').pop());
                    } else {
                        console.warn('æ— æ•ˆçš„ hwnd:', hwnd);
                    }
                } catch(appErr) {
                    // å¯èƒ½æ˜¯å•å®ä¾‹åº”ç”¨å·²åœ¨è¿è¡Œï¼Œå¯åŠ¨å‘½ä»¤å¤±è´¥
                    console.warn('å¯åŠ¨åº”ç”¨å¤±è´¥:', path, appErr);
                    // TODO: æœªæ¥å¯ä»¥å°è¯•æŸ¥æ‰¾è¯¥åº”ç”¨çš„ç°æœ‰çª—å£
                }
                
                // æ¯ä¸ªåº”ç”¨ä¹‹é—´ç¨å¾®å»¶è¿Ÿï¼Œé¿å…ç«äº‰
                await new Promise(r => setTimeout(r, 500));
            }
        } catch(e) {
            window.showError('æ¢å¤å·¥ä½œåŒºå¤±è´¥: ' + e);
        }
    };
  </script>
</body>
</html>
